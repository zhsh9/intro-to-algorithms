# Inventory

分治策略：divide and conquer

- [Inventory](#inventory)
- [基本思想](#基本思想)
  - [二分检索和二分归并排序](#二分检索和二分归并排序)
  - [分治算法的一般性描述](#分治算法的一般性描述)
- [分析技术](#分析技术)
- [改进途径](#改进途径)
  - [通过代数变换减少子问题个数](#通过代数变换减少子问题个数)
  - [通过预处理减少递归内部的计算量](#通过预处理减少递归内部的计算量)
- [典型实例](#典型实例)
  - [芯片测试](#芯片测试)
  - [幂乘计算](#幂乘计算)
  - [快排算法](#快排算法)
  - [选择问题](#选择问题)
  - [n-1 次多项式在全体 2n 次方根上的求值](#n-1-次多项式在全体-2n-次方根上的求值)

# 基本思想

分治算法的一般原则：

- 子问题均匀划分、递归处理

分治算法的设计步骤：

1. Divide, 分解阶段：将整个问题划分为多个子问题
2. Conquer, 递归求解阶段：递归调用算法求解每个子问题
3. Combine, 合并阶段：合并子问题的解，形成原始问题的解

## 二分检索和二分归并排序

最坏时间复杂度 W(n)：

1. 二分检索：$W(n) = W(\left\lfloor n/2 \right\rfloor)+1$
2. 二分归并排序：$W(n) = n\log n-n+1$

## 分治算法的一般性描述

P 是待求解的问题，|P| 是问题输入的规模：

```python
if |P| <= c: then S(P)        # 若问题规模不超c，直接求解
divide P into p1, p2, ..., pk # 否则将P归约为k个独立子问题
for i <- 1 to k:              # 递归或迭代的归约
  yi <- Divide-and-Conquer(pi)
return Merge(y1, y2, ..., yk)
```

算法时间复杂度递推方程：

$$ \left\{\begin{matrix} W(n) = W(|P_1|) + W(|P_2|) + ... + W(|P_k|) + f(n) \\ W(c) = c \end{matrix}\right. $$

# 分析技术

思路：

1. 建立递归方程
2. 求解递归方程

两类递推方程：

1. $T(n) = \sum_{i=1}a_iT(n-i)+f(n)$
   - 直接迭代法、换元法、递归树、尝试法
2. $T(n) = aT(\frac{n}{b})+f(n)$
   - 直接迭代法、递归树、[主定理](./1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#递推方程的求解)

**主定理求解的常见形式：**

1. if f(n) is c, \
  $T(n) = \left\{\begin{matrix} \Theta(n^{\log_ba}) &,a \neq 1 \\ \Theta(\log n) &,a = 1 \end{matrix}\right.$
2. if f(n) is cn, \
  $T(n) = \left\{\begin{matrix} \Theta(n) &, a < b
  \\ \Theta(n\log n) &, a = b
  \\ \Theta(n^{\log_ba}) &, a > b
  \end{matrix}\right.$

# 改进途径

## 通过代数变换减少子问题个数

## 通过预处理减少递归内部的计算量

# 典型实例

## 芯片测试

- 条件:有n 片芯片，(好芯片至少比坏芯片多1片)
- 问题:使用最少测试次数，从中挑出1片好芯片
- 方法:用其他 n-1片芯片对 A 测试
- 当n是偶数时，在上述规则下，经过一轮淘汰，剩下的好芯片比坏芯片至少多1片

时间复杂度：

$$
T(n) = \left\{\begin{matrix} W(n)=W(\frac{n}{2})+O(n) &, n > 3
\\ W(n)=1 &, n <= 3
\end{matrix}
\ \ => \ \ W(n)=O(n)
\right.
$$

![equator](https://latex.codecogs.com/gif.latex?T%28n%29%20%3D%20%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%20W%28n%29%3DW%28%5Cfrac%7Bn%7D%7B2%7D%29&plus;O%28n%29%20%26%2C%20n%20%3E%203%20%5C%5C%20W%28n%29%3D1%20%26%2C%20n%20%3C%3D%203%20%5Cend%7Bmatrix%7D%20%5C%20%5C%20%3D%3E%20%5C%20%5C%20W%28n%29%3DO%28n%29%20%5Cright.)

伪代码：

```
Test(n)

k <- n
while k > 3 do
  将芯片分为 int(k/2) 组 // 轮空芯片，特殊处理
  for i = 1 to int(k/2) do
    if 2片 good, then 任取一片留下
    else 2片都丢掉
  k <- num of remaining chips
if k = 3, then
  任取2片测试
    if 1good 1bad, then 取没测的芯片
    else 任取1片被测芯片
if k = 2 or 1, then 任取1片
```

## 幂乘计算



## 快排算法

## 选择问题

## n-1 次多项式在全体 2n 次方根上的求值